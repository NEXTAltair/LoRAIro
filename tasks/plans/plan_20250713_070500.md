# AutoCrop 3æ‰‹æ³•æ¯”è¼ƒãƒ†ã‚¹ãƒˆå¼·åŒ–ãƒ—ãƒ©ãƒ³

**ãƒ—ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°æ—¥æ™‚:** 2025/07/13 07:05  
**ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼:** Claude Code  
**å¯¾è±¡:** scripts/test_autocrop_effectiveness.py ã¸ã®å¤ã„å®Ÿè£…çµ±åˆã«ã‚ˆã‚‹3æ‰‹æ³•æ¯”è¼ƒ  

## ðŸ“‹ Executive Summary

ç¾åœ¨ã®AutoCropåŠ¹æžœç¢ºèªã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æ‹¡å¼µã—ã€çœŸã«ç•°ãªã‚‹3ã¤ã®æ‰‹æ³•ï¼ˆç¾åœ¨æœ€é©åŒ–ç‰ˆã€ç¾åœ¨ãƒ¬ã‚¬ã‚·ãƒ¼ç‰ˆã€å¢ƒç•Œå½¢çŠ¶æ¤œå‡ºç‰ˆï¼‰ã®åŒ…æ‹¬çš„æ¯”è¼ƒã‚’å®Ÿç¾ã™ã‚‹ã€‚

## ðŸŽ¯ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™

### ä¸»è¦ç›®æ¨™
1. **3æ‰‹æ³•ã®æ˜Žç¢ºãªæ¯”è¼ƒ**: è£œè‰²å·®åˆ†ãƒ™ãƒ¼ã‚¹2ç¨® + å¢ƒç•Œå½¢çŠ¶æ¤œå‡ºãƒ™ãƒ¼ã‚¹1ç¨®
2. **å®Ÿç”»åƒã§ã®é©å¿œæ€§è©•ä¾¡**: ãƒ¬ã‚¿ãƒ¼ãƒœãƒƒã‚¯ã‚¹ã‚„å¢ƒç•Œã®ãªã„ç”»åƒã§ã®å„æ‰‹æ³•ç‰¹æ€§ã®æ˜Žç¢ºåŒ–
3. **è¦–è¦šçš„æ¯”è¼ƒã®æ”¹å–„**: æ‰‹æ³•ã®æ ¹æœ¬çš„é•ã„ãŒåˆ†ã‹ã‚Šã‚„ã™ã„æ¯”è¼ƒç”»åƒç”Ÿæˆ

### æˆåŠŸåŸºæº–
- [ ] LegacyAutoCropã‚¯ãƒ©ã‚¹ãŒå¢ƒç•Œå½¢çŠ¶æ¤œå‡ºã«ã‚ˆã‚‹ã‚¯ãƒ­ãƒƒãƒ—ã‚’å®Ÿè¡Œ
- [ ] 3ã¤ã®æ‰‹æ³•ãŒåŒä¸€ç”»åƒã§ä¸¦åˆ—æ¯”è¼ƒå¯èƒ½
- [ ] å®Ÿç”»åƒãƒ†ã‚¹ãƒˆã§å„æ‰‹æ³•ã®ç‰¹æ€§ãŒæ˜Žç¢ºã«ç¾ã‚Œã‚‹
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹å·®ã®å®šé‡çš„è¨ˆæ¸¬

## ðŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### æ–°è¦è¿½åŠ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

#### LegacyAutoCropã‚¯ãƒ©ã‚¹
```python
class LegacyAutoCrop:
    """å¢ƒç•Œå½¢çŠ¶æ¤œå‡ºãƒ™ãƒ¼ã‚¹ã®AutoCropãƒ¬ã‚¬ã‚·ãƒ¼å®Ÿè£…"""
    
    def __init__(self):
        # Singleton pattern + logger initialization
        
    def crop_image(self, pil_image: Image.Image) -> tuple[Image.Image, dict]:
        """
        å¢ƒç•Œå½¢çŠ¶æ¤œå‡ºã«ã‚ˆã‚‹ã‚¯ãƒ­ãƒƒãƒ—
        
        Returns:
            tuple: (cropped_image, crop_info)
            crop_info: {
                "detected": bool,
                "method": "border_shape_detection", 
                "borders_found": list[str],
                "crop_ratio": float,
                "processing_time": float
            }
        """
        
    def _detect_border_shape(self, image: np.ndarray) -> list[str]:
        # æä¾›ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾ä½¿ç”¨
        
    def _borders_to_crop_box(self, img_shape: tuple, borders: list[str]) -> tuple[int, int, int, int]:
        """å¢ƒç•Œæƒ…å ±ã‚’ã‚¯ãƒ­ãƒƒãƒ—ãƒœãƒƒã‚¯ã‚¹(x, y, w, h)ã«å¤‰æ›"""
        height, width = img_shape[:2]
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: å…¨ä½“
        x, y, w, h = 0, 0, width, height
        
        # å¢ƒç•Œã«å¿œã˜ã¦ã‚¯ãƒ­ãƒƒãƒ—é ˜åŸŸã‚’èª¿æ•´
        border_margin = min(width, height) // 20  # 5%ã®ãƒžãƒ¼ã‚¸ãƒ³
        
        if "TOP" in borders:
            y += border_margin
            h -= border_margin
        if "BOTTOM" in borders:
            h -= border_margin
        if "LEFT" in borders:
            x += border_margin
            w -= border_margin
        if "RIGHT" in borders:
            w -= border_margin
            
        return (x, y, w, h)
```

#### æ‹¡å¼µã•ã‚ŒãŸãƒ†ã‚¹ãƒˆé–¢æ•°
```python
def apply_three_autocrop_methods(img: Image.Image, params_opt: dict, params_leg: dict) -> tuple:
    """3ã¤ã®AutoCropæ‰‹æ³•ã‚’é©ç”¨"""
    
    # 1. Current Optimized (è£œè‰²å·®åˆ†ãƒ»æœ€é©åŒ–ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿)
    opt_result, opt_info = apply_autocrop_with_params(img, params_opt)
    opt_info["method"] = "complementary_diff_optimized"
    
    # 2. Current Legacy (è£œè‰²å·®åˆ†ãƒ»å›ºå®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿)
    leg_result, leg_info = apply_autocrop_with_params(img, params_leg)  
    leg_info["method"] = "complementary_diff_legacy"
    
    # 3. True Legacy (å¢ƒç•Œå½¢çŠ¶æ¤œå‡º)
    legacy_autocrop = LegacyAutoCrop()
    true_leg_result, true_leg_info = legacy_autocrop.crop_image(img)
    
    return (opt_result, opt_info), (leg_result, leg_info), (true_leg_result, true_leg_info)

def create_three_method_comparison_image(
    original: Image.Image, 
    results: tuple, 
    test_name: str
) -> Image.Image:
    """3æ‰‹æ³•ã®æ¯”è¼ƒç”»åƒã‚’ä½œæˆ"""
    
    opt_result, opt_info = results[0]
    leg_result, leg_info = results[1] 
    true_leg_result, true_leg_info = results[2]
    
    # 4ç”»åƒãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ: Original | Optimized | Legacy | True Legacy
    # ãƒ©ãƒ™ãƒ«æƒ…å ±ã‚‚è©³ç´°åŒ–
```

### ä¾å­˜é–¢ä¿‚ã®è¿½åŠ 
```python
import scipy.ndimage  # ã‚¨ãƒƒã‚¸å¼·åº¦è¨ˆç®—ç”¨
from typing import Optional  # åž‹ãƒ’ãƒ³ãƒˆç”¨
import time  # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹è¨ˆæ¸¬ç”¨
```

## ðŸ“ è©³ç´°å®Ÿè£…è¨ˆç”»

### Phase 1: Core Implementation (1-2æ™‚é–“)

#### Task 1.1: LegacyAutoCropã‚¯ãƒ©ã‚¹åŸºç›¤ (30åˆ†)
```python
# ãƒ•ã‚¡ã‚¤ãƒ«: scripts/legacy_autocrop.py (æ–°è¦ä½œæˆ)
class LegacyAutoCrop:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(LegacyAutoCrop, cls).__new__(cls)
            cls._instance._initialize()
        return cls._instance
    
    def _initialize(self):
        # loggerè¨­å®šã¯ç°¡ç•¥åŒ–ï¼ˆprintä½¿ç”¨ï¼‰
        pass
    
    # æä¾›ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã™ã¹ã¦çµ±åˆ
    @staticmethod
    def _convert_to_gray(image: np.ndarray) -> np.ndarray:
        # æä¾›ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãã®ã¾ã¾
        
    @staticmethod  
    def _calculate_edge_strength(gray_image: np.ndarray) -> np.ndarray:
        # æä¾›ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ãã®ã¾ã¾
        
    # ... ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚åŒæ§˜
```

#### Task 1.2: å¢ƒç•Œæ¤œå‡ºâ†’ã‚¯ãƒ­ãƒƒãƒ—å¤‰æ› (45åˆ†)
```python
def _borders_to_crop_box(self, img_shape: tuple, borders: list[str]) -> tuple[int, int, int, int]:
    """
    å¢ƒç•Œãƒªã‚¹ãƒˆã‚’ã‚¯ãƒ­ãƒƒãƒ—ãƒœãƒƒã‚¯ã‚¹ã«å¤‰æ›
    
    Args:
        img_shape: (height, width, channels)
        borders: ["TOP", "BOTTOM", "LEFT", "RIGHT"] ã®çµ„ã¿åˆã‚ã›
        
    Returns:
        (x, y, width, height): ã‚¯ãƒ­ãƒƒãƒ—ãƒœãƒƒã‚¯ã‚¹
    """
    height, width = img_shape[:2]
    
    # åˆæœŸå€¤: å…¨ä½“ã®ç”»åƒ
    crop_x, crop_y = 0, 0
    crop_width, crop_height = width, height
    
    # å¢ƒç•Œã‚µã‚¤ã‚ºã®è¨ˆç®—ï¼ˆç”»åƒã‚µã‚¤ã‚ºã®5%ï¼‰
    vertical_margin = height // 20
    horizontal_margin = width // 20
    
    # å„å¢ƒç•Œã«å¿œã˜ã¦ã‚¯ãƒ­ãƒƒãƒ—é ˜åŸŸã‚’èª¿æ•´
    if "TOP" in borders:
        crop_y += vertical_margin
        crop_height -= vertical_margin
        
    if "BOTTOM" in borders:
        crop_height -= vertical_margin
        
    if "LEFT" in borders:
        crop_x += horizontal_margin
        crop_width -= horizontal_margin
        
    if "RIGHT" in borders:
        crop_width -= horizontal_margin
    
    # æœ€å°ã‚µã‚¤ã‚ºã®ä¿è¨¼
    min_size = min(width, height) // 10
    crop_width = max(crop_width, min_size)
    crop_height = max(crop_height, min_size)
    
    return (crop_x, crop_y, crop_width, crop_height)

def crop_image(self, pil_image: Image.Image) -> tuple[Image.Image, dict]:
    """å¢ƒç•Œå½¢çŠ¶æ¤œå‡ºã«ã‚ˆã‚‹ã‚¯ãƒ­ãƒƒãƒ—"""
    start_time = time.time()
    
    # NumPyé…åˆ—ã«å¤‰æ›
    np_image = np.array(pil_image)
    
    # å¢ƒç•Œå½¢çŠ¶æ¤œå‡º
    detected_borders = self._detect_border_shape(np_image)
    
    # ã‚¯ãƒ­ãƒƒãƒ—å®Ÿè¡Œ
    if detected_borders:
        crop_box = self._borders_to_crop_box(np_image.shape, detected_borders)
        x, y, w, h = crop_box
        cropped_img = pil_image.crop((x, y, x + w, y + h))
        
        crop_info = {
            "detected": True,
            "method": "border_shape_detection",
            "borders_found": detected_borders,
            "original_size": pil_image.size,
            "crop_box": crop_box,
            "cropped_size": cropped_img.size,
            "crop_ratio": (w * h) / (pil_image.size[0] * pil_image.size[1]),
            "processing_time": time.time() - start_time
        }
    else:
        cropped_img = pil_image.copy()
        crop_info = {
            "detected": False,
            "method": "border_shape_detection", 
            "borders_found": [],
            "original_size": pil_image.size,
            "crop_box": None,
            "cropped_size": pil_image.size,
            "crop_ratio": 1.0,
            "processing_time": time.time() - start_time
        }
    
    return cropped_img, crop_info
```

#### Task 1.3: ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆçµ±åˆ (45åˆ†)
```python
# ãƒ•ã‚¡ã‚¤ãƒ«: scripts/test_autocrop_effectiveness.py (ä¿®æ­£)

# ã‚¤ãƒ³ãƒãƒ¼ãƒˆè¿½åŠ 
from legacy_autocrop import LegacyAutoCrop
import scipy.ndimage
import time

# 3æ‰‹æ³•é©ç”¨é–¢æ•°
def apply_three_autocrop_methods(img: Image.Image, params_opt: dict, params_leg: dict) -> tuple:
    """3ã¤ã®AutoCropæ‰‹æ³•ã‚’é©ç”¨"""
    results = []
    
    # 1. Current Optimized
    start_time = time.time()
    opt_result, opt_info = apply_autocrop_with_params(img, params_opt)
    opt_info["method"] = "complementary_diff_optimized"
    opt_info["processing_time"] = time.time() - start_time
    results.append((opt_result, opt_info))
    
    # 2. Current Legacy  
    start_time = time.time()
    leg_result, leg_info = apply_autocrop_with_params(img, params_leg)
    leg_info["method"] = "complementary_diff_legacy"
    leg_info["processing_time"] = time.time() - start_time
    results.append((leg_result, leg_info))
    
    # 3. True Legacy
    legacy_autocrop = LegacyAutoCrop()
    true_leg_result, true_leg_info = legacy_autocrop.crop_image(img)
    results.append((true_leg_result, true_leg_info))
    
    return tuple(results)

# æ¯”è¼ƒç”»åƒç”Ÿæˆæ‹¡å¼µ
def create_four_method_comparison_image(
    original: Image.Image,
    results: tuple,
    test_name: str
) -> Image.Image:
    """4ç”»åƒã®æ¯”è¼ƒç”»åƒã‚’ä½œæˆï¼ˆã‚ªãƒªã‚¸ãƒŠãƒ« + 3æ‰‹æ³•ï¼‰"""
    
    opt_result, opt_info = results[0]
    leg_result, leg_info = results[1]
    true_leg_result, true_leg_info = results[2]
    
    # æœ€å¤§ã‚µã‚¤ã‚ºæ±ºå®š
    all_images = [original, opt_result, leg_result, true_leg_result]
    max_width = max(img.size[0] for img in all_images)
    max_height = max(img.size[1] for img in all_images)
    target_size = (max_width, max_height)
    
    # ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°é–¢æ•°
    def pad_image(img: Image.Image, target_size: tuple[int, int]) -> Image.Image:
        new_img = Image.new("RGB", target_size, (240, 240, 240))
        x_offset = (target_size[0] - img.size[0]) // 2
        y_offset = (target_size[1] - img.size[1]) // 2
        new_img.paste(img, (x_offset, y_offset))
        return new_img
    
    # ç”»åƒãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
    padded_images = [pad_image(img, target_size) for img in all_images]
    
    # æ¯”è¼ƒç”»åƒä½œæˆï¼ˆæ¨ª4åˆ—ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼‰
    text_height = 140
    comparison_width = max_width * 4 + 30  # ä½™ç™½
    comparison_height = max_height + text_height
    
    comparison = Image.new("RGB", (comparison_width, comparison_height), (255, 255, 255))
    
    # ç”»åƒé…ç½®
    for i, padded_img in enumerate(padded_images):
        x_pos = i * max_width + (i * 10)  # 10pxé–“éš”
        comparison.paste(padded_img, (x_pos, text_height))
    
    # ãƒ†ã‚­ã‚¹ãƒˆæç”»
    draw = ImageDraw.Draw(comparison)
    try:
        font = ImageFont.load_default()
    except:
        font = None
    
    # ã‚¿ã‚¤ãƒˆãƒ«
    title = f"AutoCrop 3-Method Comparison: {test_name}"
    draw.text((10, 10), title, fill=(0, 0, 0), font=font)
    
    # å„ç”»åƒã®ãƒ©ãƒ™ãƒ«
    labels = [
        f"Original\\n{original.size[0]}x{original.size[1]}",
        f"Optimized\\n{opt_info['cropped_size'][0]}x{opt_info['cropped_size'][1]}\\nRatio: {opt_info['crop_ratio']:.3f}\\nTime: {opt_info['processing_time']:.3f}s",
        f"Legacy\\n{leg_info['cropped_size'][0]}x{leg_info['cropped_size'][1]}\\nRatio: {leg_info['crop_ratio']:.3f}\\nTime: {leg_info['processing_time']:.3f}s",
        f"Border Detection\\n{true_leg_info['cropped_size'][0]}x{true_leg_info['cropped_size'][1]}\\nRatio: {true_leg_info['crop_ratio']:.3f}\\nTime: {true_leg_info['processing_time']:.3f}s\\nBorders: {', '.join(true_leg_info['borders_found']) if true_leg_info['borders_found'] else 'None'}"
    ]
    
    x_positions = [10 + i * (max_width + 10) for i in range(4)]
    for label, x_pos in zip(labels, x_positions):
        draw.text((x_pos, 50), label, fill=(0, 0, 0), font=font)
    
    return comparison
```

### Phase 2: Integration & Testing (1æ™‚é–“)

#### Task 2.1: ãƒ¡ã‚¤ãƒ³å‡¦ç†ã®ä¿®æ­£ (30åˆ†)
```python
# main()é–¢æ•°ã®ä¿®æ­£
def main():
    print("=== AutoCrop 3æ‰‹æ³•æ¯”è¼ƒã‚¹ã‚¯ãƒªãƒ—ãƒˆ ===")
    
    output_dir = Path("autocrop_test_results")
    output_dir.mkdir(exist_ok=True)
    
    # ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
    test_cases = [...]
    
    results = []
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\\n{i}. ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹: {test_case['name']}")
        
        # ãƒ†ã‚¹ãƒˆç”»åƒä½œæˆï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
        test_img = create_test_image_with_border(...)
        
        # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
        legacy_params = create_legacy_autocrop_params(test_img.size, mean_brightness)
        optimized_params = create_optimized_autocrop_params(test_img.size, mean_brightness)
        
        print(f"   Testing 3 methods:")
        print(f"   - Optimized params: {optimized_params}")
        print(f"   - Legacy params: {legacy_params}")
        print(f"   - Border detection: adaptive")
        
        try:
            # 3æ‰‹æ³•é©ç”¨
            three_results = apply_three_autocrop_methods(test_img, optimized_params, legacy_params)
            
            # æ¯”è¼ƒç”»åƒä½œæˆ
            comparison_img = create_four_method_comparison_image(test_img, three_results, test_case['name'])
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            output_path = output_dir / f"{test_case['name']}_three_methods_comparison.png"
            comparison_img.save(output_path)
            
            # çµæžœå‡ºåŠ›
            opt_info, leg_info, true_leg_info = [result[1] for result in three_results]
            print(f"   Optimized: æ¤œå‡º={opt_info['detected']}, ratio={opt_info['crop_ratio']:.3f}, time={opt_info['processing_time']:.3f}s")
            print(f"   Legacy: æ¤œå‡º={leg_info['detected']}, ratio={leg_info['crop_ratio']:.3f}, time={leg_info['processing_time']:.3f}s")
            print(f"   Border Detection: æ¤œå‡º={true_leg_info['detected']}, ratio={true_leg_info['crop_ratio']:.3f}, time={true_leg_info['processing_time']:.3f}s, borders={true_leg_info['borders_found']}")
            print(f"   æ¯”è¼ƒç”»åƒä¿å­˜: {output_path}")
            
            # çµæžœè¨˜éŒ²
            results.append({
                "test_case": test_case['name'],
                "image_size": test_img.size,
                "mean_brightness": mean_brightness,
                "optimized": opt_info,
                "legacy": leg_info, 
                "border_detection": true_leg_info
            })
            
        except Exception as e:
            print(f"   ã‚¨ãƒ©ãƒ¼: {e}")
            continue
    
    # å®Ÿç”»åƒãƒ†ã‚¹ãƒˆã‚‚3æ‰‹æ³•å¯¾å¿œã§ä¿®æ­£
    real_results = test_real_images_three_methods(output_dir)
    
    # çµæžœã‚µãƒžãƒªãƒ¼ï¼ˆ3æ‰‹æ³•å¯¾å¿œï¼‰
    print_three_method_summary(results, real_results)
```

#### Task 2.2: å®Ÿç”»åƒãƒ†ã‚¹ãƒˆæ‹¡å¼µ (30åˆ†)
```python
def test_real_images_three_methods(output_dir: Path) -> list:
    """å®Ÿç”»åƒã§ã®3æ‰‹æ³•ãƒ†ã‚¹ãƒˆ"""
    print("\\n=== å®Ÿç”»åƒ 3æ‰‹æ³•ãƒ†ã‚¹ãƒˆ ===")
    
    test_img_dir = Path("tests/resources/img/bordercrop")
    if not test_img_dir.exists():
        print(f"ãƒ†ã‚¹ãƒˆç”»åƒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {test_img_dir}")
        return []
    
    real_results = []
    image_files = list(test_img_dir.glob("*.png")) + list(test_img_dir.glob("*.jpg")) + list(test_img_dir.glob("*.jpeg"))
    
    for img_file in sorted(image_files):
        print(f"\\nå®Ÿç”»åƒ 3æ‰‹æ³•ãƒ†ã‚¹ãƒˆ: {img_file.name}")
        
        try:
            test_img = Image.open(img_file)
            if test_img.mode != "RGB":
                test_img = test_img.convert("RGB")
            
            img_array = np.array(test_img)
            mean_brightness = np.mean(cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY))
            
            print(f"   ç”»åƒã‚µã‚¤ã‚º: {test_img.size}, å¹³å‡æ˜Žåº¦: {mean_brightness:.1f}")
            
            # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç”Ÿæˆ
            legacy_params = create_legacy_autocrop_params(test_img.size, mean_brightness)
            optimized_params = create_optimized_autocrop_params(test_img.size, mean_brightness)
            
            # 3æ‰‹æ³•é©ç”¨
            three_results = apply_three_autocrop_methods(test_img, optimized_params, legacy_params)
            
            # æ¯”è¼ƒç”»åƒä½œæˆ
            comparison_img = create_four_method_comparison_image(test_img, three_results, f"Real_{img_file.stem}")
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            output_path = output_dir / f"Real_{img_file.stem}_three_methods_comparison.png"
            comparison_img.save(output_path)
            
            # çµæžœè¨˜éŒ²
            opt_info, leg_info, true_leg_info = [result[1] for result in three_results]
            
            real_results.append({
                "test_case": f"Real_{img_file.stem}",
                "source_file": str(img_file),
                "image_size": test_img.size,
                "mean_brightness": mean_brightness,
                "optimized": opt_info,
                "legacy": leg_info,
                "border_detection": true_leg_info
            })
            
            print(f"   æ¯”è¼ƒç”»åƒä¿å­˜: {output_path}")
            
        except Exception as e:
            print(f"   ã‚¨ãƒ©ãƒ¼: {e}")
            continue
    
    return real_results

def print_three_method_summary(results: list, real_results: list):
    """3æ‰‹æ³•ã®çµæžœã‚µãƒžãƒªãƒ¼ã‚’å‡ºåŠ›"""
    print("\\n=== 3æ‰‹æ³•æ¯”è¼ƒçµæžœã‚µãƒžãƒªãƒ¼ ===")
    
    if results:
        print("\\n--- åˆæˆç”»åƒãƒ†ã‚¹ãƒˆ ---")
        for result in results:
            print(f"\\n{result['test_case']}:")
            print(f"  ç”»åƒã‚µã‚¤ã‚º: {result['image_size']}")
            print(f"  Optimized: æ¤œå‡º={result['optimized']['detected']}, ratio={result['optimized']['crop_ratio']:.3f}, time={result['optimized']['processing_time']:.3f}s")
            print(f"  Legacy: æ¤œå‡º={result['legacy']['detected']}, ratio={result['legacy']['crop_ratio']:.3f}, time={result['legacy']['processing_time']:.3f}s")
            print(f"  Border Detection: æ¤œå‡º={result['border_detection']['detected']}, ratio={result['border_detection']['crop_ratio']:.3f}, time={result['border_detection']['processing_time']:.3f}s")
            print(f"  Detected Borders: {result['border_detection']['borders_found']}")
    
    if real_results:
        print("\\n--- å®Ÿç”»åƒãƒ†ã‚¹ãƒˆ ---")
        for result in real_results:
            print(f"\\n{result['test_case']}:")
            print(f"  ã‚½ãƒ¼ã‚¹: {Path(result['source_file']).name}")
            print(f"  ç”»åƒã‚µã‚¤ã‚º: {result['image_size']}")
            print(f"  Optimized: ratio={result['optimized']['crop_ratio']:.3f}, time={result['optimized']['processing_time']:.3f}s")
            print(f"  Legacy: ratio={result['legacy']['crop_ratio']:.3f}, time={result['legacy']['processing_time']:.3f}s")
            print(f"  Border Detection: ratio={result['border_detection']['crop_ratio']:.3f}, time={result['border_detection']['processing_time']:.3f}s")
            print(f"  Detected Borders: {result['border_detection']['borders_found']}")
    
    # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹æ¯”è¼ƒ
    print("\\n--- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹æ¯”è¼ƒ ---")
    all_results = results + real_results
    if all_results:
        opt_times = [r['optimized']['processing_time'] for r in all_results]
        leg_times = [r['legacy']['processing_time'] for r in all_results]
        border_times = [r['border_detection']['processing_time'] for r in all_results]
        
        print(f"å¹³å‡å‡¦ç†æ™‚é–“:")
        print(f"  Optimized: {sum(opt_times)/len(opt_times):.3f}s")
        print(f"  Legacy: {sum(leg_times)/len(leg_times):.3f}s")
        print(f"  Border Detection: {sum(border_times)/len(border_times):.3f}s")
    
    print(f"\\nãƒ†ã‚¹ãƒˆå®Œäº†: åˆæˆç”»åƒ {len(results)} ä»¶, å®Ÿç”»åƒ {len(real_results)} ä»¶")
    print("3æ‰‹æ³•ã®æ¯”è¼ƒã«ã‚ˆã‚Šã€AutoCropã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ç‰¹æ€§å·®ã‚’ç¢ºèªã§ãã¾ã™ã€‚")
```

### Phase 3: Enhancement (30åˆ†)

#### Task 3.1: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
```python
# LegacyAutoCropã‚¯ãƒ©ã‚¹ã«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¿½åŠ 
def _safe_detect_border_shape(self, image: np.ndarray) -> list[str]:
    """å®‰å…¨ãªå¢ƒç•Œå½¢çŠ¶æ¤œå‡ºï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰"""
    try:
        return self._detect_border_shape(image)
    except Exception as e:
        print(f"Border detection error: {e}")
        return []  # æ¤œå‡ºå¤±æ•—æ™‚ã¯ç©ºãƒªã‚¹ãƒˆ

def _safe_borders_to_crop_box(self, img_shape: tuple, borders: list[str]) -> tuple[int, int, int, int]:
    """å®‰å…¨ãªã‚¯ãƒ­ãƒƒãƒ—ãƒœãƒƒã‚¯ã‚¹å¤‰æ›ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰"""
    try:
        if not borders:
            height, width = img_shape[:2]
            return (0, 0, width, height)  # å…¨ä½“ã‚’è¿”ã™
        return self._borders_to_crop_box(img_shape, borders)
    except Exception as e:
        print(f"Crop box conversion error: {e}")
        height, width = img_shape[:2]
        return (0, 0, width, height)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å…¨ä½“ã‚’è¿”ã™
```

#### Task 3.2: ä¾å­˜é–¢ä¿‚ç®¡ç†
```python
# scripts/test_autocrop_effectiveness.py ã®å…ˆé ­ã«ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯è¿½åŠ 
def check_dependencies():
    """å¿…è¦ãªä¾å­˜é–¢ä¿‚ã‚’ãƒã‚§ãƒƒã‚¯"""
    try:
        import scipy.ndimage
        print("âœ“ scipy.ndimage available")
    except ImportError:
        print("âœ— scipy.ndimage not found. Run: uv add scipy")
        return False
    
    try:
        import cv2
        print("âœ“ opencv-python available")
    except ImportError:
        print("âœ— opencv-python not found. Run: uv add opencv-python")
        return False
    
    return True

# main()ã®å…ˆé ­ã§å®Ÿè¡Œ
def main():
    if not check_dependencies():
        print("Required dependencies missing. Please install them first.")
        return
    
    print("=== AutoCrop 3æ‰‹æ³•æ¯”è¼ƒã‚¹ã‚¯ãƒªãƒ—ãƒˆ ===")
    # ä»¥ä¸‹ã€æ—¢å­˜ã®å‡¦ç†...
```

## ðŸ“Š æœŸå¾…ã•ã‚Œã‚‹çµæžœ

### åˆæˆç”»åƒã§ã®äºˆæƒ³çµæžœ
```
Small_Gradient (200x200):
  Optimized: ratio=0.504, time=0.120s
  Legacy: ratio=0.570, time=0.115s  
  Border Detection: ratio=0.640, time=0.095s, borders=['TOP', 'BOTTOM', 'LEFT', 'RIGHT']

Medium_Pattern (400x400):
  Optimized: ratio=0.597, time=0.145s
  Legacy: ratio=0.605, time=0.140s
  Border Detection: ratio=0.680, time=0.110s, borders=['TOP', 'BOTTOM', 'LEFT', 'RIGHT']
```

### å®Ÿç”»åƒã§ã®äºˆæƒ³çµæžœ
```
Real_image_0001 (ãƒ¬ã‚¿ãƒ¼ãƒœãƒƒã‚¯ã‚¹):
  Optimized: ratio=0.001, time=0.250s  # è£œè‰²å·®åˆ†ã§ã¯æ¤œå‡ºå¤±æ•—
  Legacy: ratio=0.001, time=0.245s     # è£œè‰²å·®åˆ†ã§ã¯æ¤œå‡ºå¤±æ•—
  Border Detection: ratio=0.750, time=0.180s, borders=['TOP', 'BOTTOM']  # ä¸Šä¸‹é»’å¸¯æ¤œå‡º

Real_image_0006 (ã‚²ãƒ¼ãƒ ç”»é¢):
  Optimized: ratio=0.002, time=0.180s  # è£œè‰²å·®åˆ†ã§ã¯æ¤œå‡ºå¤±æ•—
  Legacy: ratio=0.003, time=0.175s     # è£œè‰²å·®åˆ†ã§ã¯æ¤œå‡ºå¤±æ•—
  Border Detection: ratio=1.000, time=0.150s, borders=[]  # å¢ƒç•Œãªã—
```

### æ‰‹æ³•ç‰¹æ€§ã®æ˜Žç¢ºåŒ–
1. **è£œè‰²å·®åˆ†ãƒ™ãƒ¼ã‚¹**: åˆæˆç”»åƒã§ã¯å‹•ä½œã™ã‚‹ãŒã€å®Ÿç”»åƒã§ã¯æ©Ÿèƒ½ä¸å…¨
2. **å¢ƒç•Œå½¢çŠ¶æ¤œå‡ºãƒ™ãƒ¼ã‚¹**: ãƒ¬ã‚¿ãƒ¼ãƒœãƒƒã‚¯ã‚¹æ¤œå‡ºã«å„ªã‚Œã€å®Ÿç”»åƒã«é©å¿œçš„

## ðŸš€ å®Ÿè£…å„ªå…ˆåº¦

### é«˜å„ªå…ˆåº¦ (å¿…é ˆ)
- [x] LegacyAutoCropã‚¯ãƒ©ã‚¹å®Ÿè£…
- [x] å¢ƒç•Œæ¤œå‡ºâ†’ã‚¯ãƒ­ãƒƒãƒ—å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯
- [x] 3æ‰‹æ³•çµ±åˆãƒ†ã‚¹ãƒˆé–¢æ•°
- [x] 4ç”»åƒæ¯”è¼ƒç”»åƒç”Ÿæˆ

### ä¸­å„ªå…ˆåº¦ (æŽ¨å¥¨)
- [x] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹è¨ˆæ¸¬
- [x] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
- [x] è©³ç´°çµæžœã‚µãƒžãƒªãƒ¼

### ä½Žå„ªå…ˆåº¦ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
- [ ] CSV/JSONçµæžœå‡ºåŠ›
- [ ] çµ±è¨ˆçš„åˆ†æžãƒ¬ãƒãƒ¼ãƒˆ
- [ ] è¨­å®šå¯èƒ½ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

## ðŸ”§ å®Ÿè£…å®Œäº†åŸºæº–

### æ©Ÿèƒ½è¦ä»¶
- [ ] 3ã¤ã®ç•°ãªã‚‹æ‰‹æ³•ãŒåŒä¸€ç”»åƒã§å®Ÿè¡Œå¯èƒ½
- [ ] å¢ƒç•Œå½¢çŠ¶æ¤œå‡ºãŒå®Ÿéš›ã®ã‚¯ãƒ­ãƒƒãƒ—ã«åæ˜ ã•ã‚Œã‚‹
- [ ] å®Ÿç”»åƒã§ã®ãƒ¬ã‚¿ãƒ¼ãƒœãƒƒã‚¯ã‚¹æ¤œå‡ºãŒæ”¹å–„ã•ã‚Œã‚‹
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹å·®ãŒå®šé‡çš„ã«è¨ˆæ¸¬ã•ã‚Œã‚‹

### å“è³ªè¦ä»¶
- [ ] å…¨ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã§ã‚¨ãƒ©ãƒ¼ãªãå®Ÿè¡Œ
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒåˆç†çš„ç¯„å›²å†…
- [ ] æ¯”è¼ƒç”»åƒãŒè¦–è¦šçš„ã«åˆ†ã‹ã‚Šã‚„ã™ã„
- [ ] çµæžœã‚µãƒžãƒªãƒ¼ãŒåŒ…æ‹¬çš„

## ðŸ“ˆ æˆåŠŸè©•ä¾¡æŒ‡æ¨™

### å®šé‡çš„æŒ‡æ¨™
1. **å®Ÿç”»åƒãƒ¬ã‚¿ãƒ¼ãƒœãƒƒã‚¯ã‚¹æ¤œå‡ºçŽ‡**: Border Detection > 50% vs Others < 5%
2. **å‡¦ç†æ™‚é–“æ¯”è¼ƒ**: Border Detection < Complementary Diff (è»½é‡å‡¦ç†)
3. **é©å¿œæ€§è©•ä¾¡**: ç”»åƒã‚¿ã‚¤ãƒ—åˆ¥ã§ã®å„æ‰‹æ³•ã®æ€§èƒ½å·®

### å®šæ€§çš„æŒ‡æ¨™
1. **è¦–è¦šçš„åˆ†ã‹ã‚Šã‚„ã™ã•**: 3æ‰‹æ³•ã®é•ã„ãŒä¸€ç›®ã§ç†è§£å¯èƒ½
2. **å®Ÿç”¨æ€§è©•ä¾¡**: å®Ÿç”»åƒã§ã®å„æ‰‹æ³•ã®é©ç”¨å¯èƒ½æ€§ãŒæ˜Žç¢º
3. **é–‹ç™ºåŠ¹çŽ‡**: ä»Šå¾Œã®AutoCropæ”¹å–„æ–¹é‡ã®æ±ºå®šã«å¯„ä¸Ž

## ðŸ“‹ æ¬¡ã‚¹ãƒ†ãƒƒãƒ—

1. **Phase 1å®Ÿè£…**: LegacyAutoCropã‚¯ãƒ©ã‚¹ã¨åŸºæœ¬çµ±åˆ
2. **Phase 2å®Ÿè£…**: ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆæ‹¡å¼µã¨æ¯”è¼ƒç”»åƒå¼·åŒ–
3. **Phase 3å®Ÿè£…**: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹è¨ˆæ¸¬
4. **çµæžœæ¤œè¨¼**: å®Ÿç”»åƒã§ã®3æ‰‹æ³•ã®ç‰¹æ€§ç¢ºèª
5. **æ”¹å–„æ–¹é‡æ±ºå®š**: æœ€é©ãªæ‰‹æ³•ã®é¸æŠžã¨ä»Šå¾Œã®é–‹ç™ºæ–¹é‡ç­–å®š

---

**ãƒ—ãƒ©ãƒ³å®Œäº†æ™‚åˆ»:** 2025/07/13 07:05  
**æŽ¨å®šå®Ÿè£…æ™‚é–“:** 2-3æ™‚é–“  
**å®Ÿè£…å„ªå…ˆåº¦:** é«˜ï¼ˆAutoCropæ”¹å–„ã®åŸºç›¤ã¨ãªã‚‹é‡è¦ãªæ¯”è¼ƒæ¤œè¨¼ï¼‰  

**æ¬¡ã‚³ãƒžãƒ³ãƒ‰:** `@implement LegacyAutoCropçµ±åˆã«ã‚ˆã‚‹3æ‰‹æ³•æ¯”è¼ƒå®Ÿè£…`