# データベースアクセス処理リファクタリング計画書

## 概要

### 目的
GUI層に混在している約3,167行のデータベースアクセス処理を適切な層に分離し、アーキテクチャの明確化と保守性の向上を実現する。

### 現状の問題点
- **責任分離不備**: GUI層にデータベース操作ロジックが大量に混在
- **アーキテクチャの不明確**: データアクセス層とGUI層の責務が曖昧
- **保守性の低下**: データベース操作の変更がUIに直接影響
- **テスト困難性**: データベース操作とUIが密結合で単体テストが困難
- **再利用性の欠如**: データベース操作ロジックがGUI層に縛られている

### 対象ファイルと行数（更新版）

#### **主要対象ファイル（計画書当初の対象）**
- `src/lorairo/gui/window/main_workspace_window.py` (943行)
  - `_get_images_from_current_directory()` - ディレクトリ内画像のDB取得処理
  - `_refresh_dataset_from_db()` - データセットのDB更新処理
  - `update_db_status()` - DB状態の取得・表示処理
- `src/lorairo/gui/workers/database_worker.py` (378行)
  - `DatabaseRegistrationWorker` - データベース登録処理
  - `SearchWorker` - データベース検索処理
  - `ThumbnailWorker` - サムネイル読み込み処理
- `src/lorairo/gui/widgets/filter_search_panel.py` (596行)
  - `_process_search_conditions()` - 検索条件のDB用変換処理
  - `_process_option_filters()` - フィルター条件のDB用変換処理

#### **追加対象ファイル（調査で判明）**
- `src/lorairo/gui/window/main_workspace_window.py` 追加処理 (約300行)
  - `handle_search_requested()` - 検索条件のDB実行処理
  - `handle_search_finished()` - 検索結果のDB処理
  - `_apply_frontend_filtering()` - フロントエンドフィルタリング処理
  - `_filter_by_date_range()` - 日付範囲フィルタリング処理
  - `_resolve_optimal_thumbnail_data()` - サムネイルデータのDB取得処理
  - `_start_thumbnail_loading()` - サムネイル読み込みのDB処理

- `src/lorairo/gui/workers/database_worker.py` 追加処理 (約200行)
  - `_process_associated_files()` - 関連ファイル（.txt/.caption）のDB処理
  - `_get_thumbnail_path()` - サムネイルパスのDB取得処理
  - `_check_processed_image_exists()` - 処理済み画像のDB存在チェック

- `src/lorairo/gui/widgets/filter_search_panel.py` 追加処理 (約150行)
  - `_process_resolution_filter()` - 解像度フィルターのDB変換処理
  - `_process_date_filter()` - 日付フィルターのDB変換処理
  - `_apply_untagged_filter()` - 未タグフィルターのDB処理
  - `_apply_tagged_filter_logic()` - タグ付きフィルターロジックのDB処理

- `src/lorairo/gui/widgets/annotation_status_filter_widget.py` (約100行)
  - `update_status_counts()` - アノテーション状態のDB集計処理
  - `set_database_manager()` - データベースマネージャーの設定処理

- `src/lorairo/services/batch_processor.py` (約200行)
  - `process_directory_batch()` - バッチ処理でのDB操作
  - `_process_associated_files()` - 関連ファイルのDB処理

- `src/lorairo/services/image_processing_service.py` (約300行)
  - 画像処理時のDB操作処理

**総計: 約3,167行**のDBアクセス処理が分散している

### 実際のDBアクセスメソッド（ImageDatabaseManager）

#### **検索・取得系**
- `get_images_by_filter()` - 条件付き画像検索
- `detect_duplicate_image()` - 重複画像検出
- `get_image_metadata()` - 画像メタデータ取得
- `get_image_ids_from_directory()` - ディレクトリ内画像ID取得
- `get_total_image_count()` - 総画像数取得
- `check_processed_image_exists()` - 処理済み画像存在チェック

#### **登録・更新系**
- `register_original_image()` - オリジナル画像登録
- `save_tags()` - タグ保存
- `save_captions()` - キャプション保存

#### **モデル・アノテーション系**
- `get_models()` - モデル情報取得
- `get_models_by_type()` - タイプ別モデル取得
- `get_upscaler_models()` - アップスケーラーモデル取得
- `get_llm_models()` - LLMモデル取得

## アーキテクチャ設計

### 既存アーキテクチャの活用
既存のクリーンアーキテクチャを基盤として、以下の層分離を実現する：

```
GUI Layer (PySide6依存)
├── UI表示・ユーザーインタラクション
├── シグナル・スロット接続
└── PySide6並列処理 (QThreadPool)

Service Layer (ビジネスロジック)
├── ImageProcessingService
├── AnnotationService
├── ConfigurationService
└── 拡張: SearchFilterService
└── 新規: DatabaseOperationService

Repository Layer (データアクセス)
├── ImageDatabaseManager (既存)
├── ImageRepository (既存)
└── 拡張: SearchFilterService

Infrastructure Layer
├── SQLite Database
├── File System
└── External APIs
```

### 責任分離の詳細

#### 移動対象（データベースアクセス処理）

##### SearchFilterService に移動（検索・フィルタリング専用）
1. **データ取得処理（軽量な読み取り操作）**
   - ディレクトリ内画像のDB取得
   - データセットのDB状態取得
   - DB状態の取得・表示
   - 検索結果のDB処理
   - サムネイルデータのDB取得
   - 処理済み画像のDB存在チェック

2. **データ検索処理（軽量な読み取り操作）**
   - 検索条件の構築
   - フィルター条件の構築
   - クエリ実行と結果変換
   - フロントエンドフィルタリング

3. **データ変換処理（軽量な読み取り操作）**
   - 検索条件のDB用変換
   - フィルター条件のDB用変換
   - 結果データの形式変換
   - 日付範囲フィルタリング

##### DatabaseOperationService に移動（データ操作専用）
4. **データ登録処理（重い書き込み操作）**
   - 画像ファイルのDB登録
   - 重複チェック処理
   - 関連ファイル処理
   - バッチ処理でのDB操作

5. **アノテーション処理（データ更新操作）**
   - アノテーション状態のDB集計
   - タグ・キャプションのDB処理
   - アノテーション状態の更新

#### GUI固有の処理（残す）
1. **UI状態管理**
   - サムネイルサイズ、レイアウトモード
   - 選択状態管理
   - プログレスダイアログ管理

2. **シグナル・スロット**
   - Qt固有の通信機構
   - ワーカーとの連携

3. **並列処理**
   - QThreadを使用したバックグラウンド処理
   - ワーカーのライフサイクル管理

## 実装計画

### Phase 1: 準備作業

#### 1.1 既存データベース層の分析
- `src/lorairo/database/db_manager.py` の既存メソッド確認
- `src/lorairo/database/db_repository.py` の利用可能な機能確認
- 重複機能の特定と統合計画

#### 1.2 依存関係マップの作成
```python
# 調査対象のimport文
from ...database.db_manager import ImageDatabaseManager
from ...database.db_repository import ImageRepository
from ...database.db_core import DefaultSessionLocal
```

#### 1.3 既存サービスの活用・拡張
```python
# 既存: src/lorairo/gui/services/search_filter_service.py を拡張
class SearchFilterService:
    """検索・フィルター処理に関するビジネスロジックを処理するサービス（拡張版）"""

    def __init__(self, db_manager: ImageDatabaseManager):  # データベースマネージャーを注入
        self.db_manager = db_manager
        self.current_conditions: SearchConditions | None = None

    # 既存メソッド（そのまま維持）
    # - parse_search_input()
    # - create_search_conditions()
    # - separate_search_and_filter_conditions()
    # - create_search_preview()

    # 新規追加メソッド
    def get_directory_images(self, directory_path: Path) -> list[dict]:
        """ディレクトリ内画像の取得"""

    def get_dataset_status(self) -> dict:
        """データセット状態の取得"""

    def execute_search(self, conditions: SearchConditions) -> tuple[list[dict], int]:
        """検索条件を実行してデータベースから結果を取得"""

    def process_associated_files(self, image_path: Path, image_id: int) -> None:
        """関連ファイル（.txt/.caption）の処理"""

    def get_thumbnail_data(self, image_metadata: list[dict]) -> list[tuple[Path, int]]:
        """サムネイルデータの取得"""

    def check_processed_image_exists(self, image_id: int, resolution: int) -> dict | None:
        """処理済み画像の存在チェック"""
```

#### 1.4 新規サービスの設計

##### サービス分離の意図と責務の違い

**SearchFilterService と DatabaseOperationService の分離理由:**

1. **責務の明確な分離**
   - **SearchFilterService**: 検索・フィルタリング専用（読み取り操作中心）
   - **DatabaseOperationService**: データ操作専用（書き込み・更新操作中心）

2. **処理の性質の違い**
   - **SearchFilterService**: 軽量な即座実行可能な処理
   - **DatabaseOperationService**: 重いバッチ処理やファイルシステム操作を伴う処理

3. **パフォーマンス特性の違い**
   - **SearchFilterService**: ユーザーの検索要求に即座に応答、キャッシュ可能
   - **DatabaseOperationService**: 長時間の処理、進捗報告、キャンセル可能

4. **エラーハンドリングの違い**
   - **SearchFilterService**: 軽微なエラー処理（空の結果を返す）
   - **DatabaseOperationService**: 詳細なエラー処理（部分的な失敗でも継続）

5. **依存関係の違い**
   - **SearchFilterService**: `ImageDatabaseManager`のみに依存
   - **DatabaseOperationService**: `ImageDatabaseManager` + `FileSystemManager`に依存

```python
# 新規: src/lorairo/services/database_operation_service.py
class DatabaseOperationService:
    """データベース操作に関するビジネスロジックを処理するサービス
    検索・フィルタリング以外のデータ操作（登録、更新、削除、バッチ処理）を担当
    """

    def __init__(self, db_manager: ImageDatabaseManager):
        self.db_manager = db_manager

    def register_images_batch(self, directory: Path, fsm: FileSystemManager,
                            progress_callback: Callable = None) -> DatabaseRegistrationResult:
        """バッチ画像登録処理（重い処理）"""

    def process_associated_files(self, image_path: Path, image_id: int) -> None:
        """関連ファイル処理（ファイルシステム操作）"""

    def get_annotation_status_counts(self) -> dict:
        """アノテーション状態の集計"""

    def update_annotation_status(self, image_id: int, status: str) -> None:
        """アノテーション状態の更新"""
```

### Phase 2: 段階的移行

#### 2.1 GUI層のデータベースアクセス処理分離（約1,243行）

**対象メソッド**:
- `_get_images_from_current_directory()` → `SearchFilterService.get_directory_images()`
- `_refresh_dataset_from_db()` → `SearchFilterService.refresh_dataset()`
- `update_db_status()` → `SearchFilterService.get_dataset_status()`
- `handle_search_requested()` → `SearchFilterService.execute_search()`
- `handle_search_finished()` → `SearchFilterService.process_search_results()`
- `_apply_frontend_filtering()` → `SearchFilterService.apply_frontend_filters()`
- `_filter_by_date_range()` → `SearchFilterService.filter_by_date_range()`
- `_resolve_optimal_thumbnail_data()` → `SearchFilterService.get_thumbnail_data()`
- `_start_thumbnail_loading()` → `SearchFilterService.load_thumbnails()`

**実装手順**:
1. 既存の `SearchFilterService` にデータベース関連メソッドを追加
2. 既存メソッドの機能を拡張サービスに移行
3. GUI層での呼び出しを拡張サービスに変更
4. テスト実行と動作確認

#### 2.2 ワーカー層のデータベースアクセス処理分離（約578行）

**対象クラス**:
- `DatabaseRegistrationWorker` → `DatabaseOperationService.register_images_batch()`
- `SearchWorker` → `SearchFilterService.execute_search()`
- `ThumbnailWorker` → `SearchFilterService.load_thumbnails()`
- `_process_associated_files()` → `DatabaseOperationService.process_associated_files()`
- `_get_thumbnail_path()` → `SearchFilterService.get_thumbnail_path()`
- `_check_processed_image_exists()` → `SearchFilterService.check_processed_image_exists()`

**実装手順**:
1. ワーカー内のデータベース処理を拡張サービスに移行
2. ワーカーはPySide6依存の並列処理のみに集中
3. シグナル・スロット接続の維持
4. テスト実行と動作確認

#### 2.3 ウィジェット層のデータベースアクセス処理分離（約746行）

**対象メソッド**:
- `_process_search_conditions()` → `SearchFilterService.separate_search_and_filter_conditions()`（既存活用）
- `_process_option_filters()` → `SearchFilterService.create_search_conditions()`（既存活用）
- `_process_resolution_filter()` → `SearchFilterService.process_resolution_filter()`
- `_process_date_filter()` → `SearchFilterService.process_date_filter()`
- `_apply_untagged_filter()` → `SearchFilterService.apply_untagged_filter()`
- `_apply_tagged_filter_logic()` → `SearchFilterService.apply_tagged_filter_logic()`
- `update_status_counts()` → `DatabaseOperationService.get_annotation_status_counts()`

**実装手順**:
1. 既存の `SearchFilterService` の検索・フィルター処理を活用
2. ウィジェットはUI表示とユーザーインタラクションのみに集中
3. 既存の条件変換ロジックを活用
4. テスト実行と動作確認

#### 2.4 サービス層のデータベースアクセス処理分離（約500行）

**対象ファイル**:
- `batch_processor.py` → `DatabaseOperationService.register_images_batch()`
- `image_processing_service.py` → `DatabaseOperationService.process_image_operations()`

**実装手順**:
1. サービス層内のデータベース処理を専用サービスに移行
2. 既存サービスの責務を明確化
3. 依存関係の最適化
4. テスト実行と動作確認

### Phase 3: インターフェース設計

#### 3.1 シグナル・スロット接続の維持
```python
# 既存のシグナル接続を維持
class MainWorkspaceWindow:
    def __init__(self):
        self.search_filter_service = SearchFilterService(self.db_manager)
        self.database_operation_service = DatabaseOperationService(self.db_manager)
        # 既存のシグナル接続は変更なし

    def handle_search_requested(self, conditions: dict):
        # 拡張サービスを使用
        result = self.search_filter_service.execute_search(conditions)
        self.handle_search_finished(result)
```

#### 3.2 依存関係の最適化
```python
# 循環依存の回避
# GUI層 → Service層 → Repository層 の一方向依存
from ...gui.services.search_filter_service import SearchFilterService
from ...services.database_operation_service import DatabaseOperationService
from ...database.db_manager import ImageDatabaseManager
```

### Phase 4: 最終調整

#### 4.1 テストの実行
- 各フェーズでの単体テスト
- 統合テストの実行
- パフォーマンステスト

#### 4.2 ドキュメントの更新
- アーキテクチャドキュメントの更新
- API仕様書の更新
- 移行ガイドの作成

## 実装詳細

### 既存サービスの拡張設計

#### SearchFilterService の拡張（検索・フィルタリング専用）
```python
# src/lorairo/gui/services/search_filter_service.py に追加
from pathlib import Path
from typing import Any, list
from ...database.db_manager import ImageDatabaseManager
from ...utils.log import logger

class SearchFilterService:
    """検索・フィルター処理に関するビジネスロジックを処理するサービス（拡張版）
    軽量な読み取り操作中心の処理を担当
    """

    def __init__(self, db_manager: ImageDatabaseManager):  # データベースマネージャーを注入
        self.db_manager = db_manager
        self.current_conditions: SearchConditions | None = None
        self.logger = logger

    # 既存メソッド（そのまま維持）
    # - parse_search_input()
    # - create_search_conditions()
    # - separate_search_and_filter_conditions()
    # - create_search_preview()

    # 新規追加メソッド（検索・フィルタリング関連）
    def get_directory_images(self, directory_path: Path) -> list[dict]:
        """ディレクトリ内画像の取得（軽量な読み取り操作）"""
        try:
            image_ids = self.db_manager.get_image_ids_from_directory(directory_path)
            return self._get_images_metadata(image_ids)
        except Exception as e:
            self.logger.error(f"ディレクトリ画像取得エラー: {e}")
            return []

    def get_dataset_status(self) -> dict:
        """データセット状態の取得（軽量な読み取り操作）"""
        try:
            total_count = self.db_manager.get_total_image_count()
            return {
                "total_images": total_count,
                "status": "ready" if total_count > 0 else "empty"
            }
        except Exception as e:
            self.logger.error(f"データセット状態取得エラー: {e}")
            return {"total_images": 0, "status": "error"}

    def execute_search(self, conditions: SearchConditions) -> tuple[list[dict], int]:
        """検索条件を実行してデータベースから結果を取得（軽量な読み取り操作）"""
        try:
            search_conditions, filter_conditions = self.separate_search_and_filter_conditions(conditions)
            return self.db_manager.get_images_by_filter(**search_conditions)
        except Exception as e:
            self.logger.error(f"画像検索エラー: {e}")
            return [], 0

    def get_thumbnail_data(self, image_metadata: list[dict]) -> list[tuple[Path, int]]:
        """サムネイルデータの取得（軽量な読み取り操作）"""
        try:
            # 既存のサムネイルデータ取得ロジックを移行
            pass
        except Exception as e:
            self.logger.error(f"サムネイルデータ取得エラー: {e}")
            return []

    def check_processed_image_exists(self, image_id: int, resolution: int) -> dict | None:
        """処理済み画像の存在チェック（軽量な読み取り操作）"""
        try:
            return self.db_manager.check_processed_image_exists(image_id, resolution)
        except Exception as e:
            self.logger.error(f"処理済み画像チェックエラー: {e}")
            return None
```

### 新規サービスの設計

#### DatabaseOperationService の実装（データ操作専用）
```python
# src/lorairo/services/database_operation_service.py
from pathlib import Path
from typing import Any, Callable
from ...database.db_manager import ImageDatabaseManager
from ...storage.file_system import FileSystemManager
from ...utils.log import logger

class DatabaseOperationService:
    """データベース操作に関するビジネスロジックを処理するサービス
    重い書き込み・更新操作やファイルシステム操作を伴う処理を担当
    """

    def __init__(self, db_manager: ImageDatabaseManager):
        self.db_manager = db_manager
        self.logger = logger

    def register_images_batch(self, directory: Path, fsm: FileSystemManager,
                            progress_callback: Callable = None) -> DatabaseRegistrationResult:
        """バッチ画像登録処理（重い処理、進捗報告、キャンセル可能）"""
        try:
            # 既存のバッチ処理ロジックを移行
            # ファイルスキャン → 重複チェック → ファイルコピー → DB登録 → 関連ファイル処理
            pass
        except Exception as e:
            self.logger.error(f"バッチ登録エラー: {e}")
            return DatabaseRegistrationResult(0, 0, 0, [], 0.0)

    def process_associated_files(self, image_path: Path, image_id: int) -> None:
        """関連ファイル処理（ファイルシステム操作を伴う）"""
        try:
            # 既存の関連ファイル処理ロジックを移行
            # .txt/.captionファイルの読み込み → DB保存
            pass
        except Exception as e:
            self.logger.error(f"関連ファイル処理エラー: {e}")

    def get_annotation_status_counts(self) -> dict:
        """アノテーション状態の集計（データ集計処理）"""
        try:
            # 既存のアノテーション状態集計ロジックを移行
            pass
        except Exception as e:
            self.logger.error(f"アノテーション状態集計エラー: {e}")
            return {}

    def update_annotation_status(self, image_id: int, status: str) -> None:
        """アノテーション状態の更新（データ更新処理）"""
        try:
            # 既存のアノテーション状態更新ロジックを移行
            pass
        except Exception as e:
            self.logger.error(f"アノテーション状態更新エラー: {e}")
```

### GUI層の簡素化

#### MainWorkspaceWindow の変更
```python
# src/lorairo/gui/window/main_workspace_window.py
class MainWorkspaceWindow(QMainWindow, Ui_MainWorkspaceWindow):
    def __init__(self, parent=None):
        # 既存の初期化
        self.db_manager = ImageDatabaseManager(image_repo, self.config_service, self.fsm)

        # 既存のSearchFilterServiceを拡張して使用
        self.search_filter_service = SearchFilterService(self.db_manager)

        # 新規DatabaseOperationServiceを追加
        self.database_operation_service = DatabaseOperationService(self.db_manager)

        # 既存のワーカーサービス
        self.worker_service = WorkerService(self.db_manager, self.fsm, self)

    def _get_images_from_current_directory(self) -> list[dict]:
        """ディレクトリ内画像のDB取得処理（簡素化）"""
        if not self.current_dataset_path:
            return []

        return self.search_filter_service.get_directory_images(self.current_dataset_path)

    def update_db_status(self) -> None:
        """DB状態の取得・表示処理（簡素化）"""
        status = self.search_filter_service.get_dataset_status()

        # UI更新（既存のまま）
        self.labelDatabaseStatus.setText(f"画像数: {status['total_images']}")
        self.labelDatabaseStatus.setStyleSheet(
            "color: green;" if status['status'] == 'ready' else "color: red;"
        )

    def handle_search_requested(self, conditions: dict) -> None:
        """検索要求処理（簡素化）"""
        try:
            result = self.search_filter_service.execute_search(conditions)
            self.handle_search_finished(result)
        except Exception as e:
            self.handle_search_error(str(e))
```

#### FilterSearchPanel の変更
```python
# src/lorairo/gui/widgets/filter_search_panel.py
class FilterSearchPanel(QScrollArea):
    def __init__(self, parent=None, dataset_state: DatasetStateManager | None = None):
        super().__init__(parent)
        self.dataset_state = dataset_state
        # データベース処理は親から注入
        self.search_filter_service = None

    def set_search_filter_service(self, search_filter_service: SearchFilterService):
        """検索・フィルターサービスを設定"""
        self.search_filter_service = search_filter_service

    def _process_search_conditions(self, db_conditions: dict[str, Any]) -> None:
        """検索条件のDB用変換処理（簡素化）"""
        if self.search_filter_service:
            # 既存のSearchFilterServiceの機能を活用
            conditions = self.search_filter_service.get_current_conditions()
            if conditions:
                search_conditions, filter_conditions = self.search_filter_service.separate_search_and_filter_conditions(conditions)
                db_conditions.update(search_conditions)
```

### ワーカー層の簡素化

#### DatabaseRegistrationWorker の変更
```python
# src/lorairo/gui/workers/database_worker.py
class DatabaseRegistrationWorker(LoRAIroWorkerBase[DatabaseRegistrationResult]):
    def __init__(
        self,
        directory: Path,
        database_operation_service: DatabaseOperationService,
        fsm: FileSystemManager
    ) -> None:
        super().__init__()
        self.directory = directory
        self.database_operation_service = database_operation_service
        self.fsm = fsm

    def execute(self) -> DatabaseRegistrationResult:
        """データベース登録処理を実行（簡素化）"""
        # 拡張サービスに委譲
        return self.database_operation_service.register_images_batch(
            self.directory,
            self.fsm,
            progress_callback=self._report_progress
        )
```

## テスト戦略

### 単体テスト
```python
# tests/unit/test_search_filter_service.py
import pytest
from unittest.mock import Mock, patch
from lorairo.gui.services.search_filter_service import SearchFilterService

class TestSearchFilterService:
    def setup_method(self):
        self.mock_db_manager = Mock()
        self.service = SearchFilterService(self.mock_db_manager)

    def test_get_directory_images(self):
        # テスト実装
        pass

    def test_execute_search(self):
        # テスト実装
        pass

    def test_separate_search_and_filter_conditions(self):
        # 既存メソッドのテスト
        pass

# tests/unit/test_database_operation_service.py
import pytest
from unittest.mock import Mock, patch
from lorairo.services.database_operation_service import DatabaseOperationService

class TestDatabaseOperationService:
    def setup_method(self):
        self.mock_db_manager = Mock()
        self.service = DatabaseOperationService(self.mock_db_manager)

    def test_register_images_batch(self):
        # テスト実装
        pass

    def test_process_associated_files(self):
        # テスト実装
        pass
```

### 統合テスト
```python
# tests/integration/test_gui_database_integration.py
import pytest
from PySide6.QtWidgets import QApplication
from lorairo.gui.window.main_workspace_window import MainWorkspaceWindow

class TestGuiDatabaseIntegration:
    def test_database_status_update(self, qtbot):
        # テスト実装
        pass

    def test_search_functionality(self, qtbot):
        # テスト実装
        pass

    def test_batch_registration(self, qtbot):
        # テスト実装
        pass
```

## リスクと対策

### リスク1: 既存機能の動作に影響
**対策**:
- 段階的移行による影響範囲の最小化
- 各フェーズでのテスト実施
- ロールバック手順の準備

### リスク2: 開発期間の延長
**対策**:
- 優先度の高い部分から順次実施
- 並行開発による効率化
- 既存コードの最大活用

### リスク3: パフォーマンスの劣化
**対策**:
- 既存の最適化手法の維持
- プロファイリングによる性能監視
- 必要に応じたキャッシュ機能の実装

### リスク4: 移行対象の拡大
**対策**:
- 段階的な移行計画の策定
- 各フェーズでの影響範囲の明確化
- 優先度に基づく移行順序の決定

## 成功指標

### 短期的効果
- [ ] 約3,167行のデータベースアクセス処理が適切な層に移動
- [ ] GUI層が純粋なUI表示・インタラクション・PySide6並列処理に集中
- [ ] 既存の `SearchFilterService` を最大限活用
- [ ] 新規 `DatabaseOperationService` の実装
- [ ] 新規ファイル作成を最小限に抑制
- [ ] 単体テストの実装が容易になった
- [ ] 既存機能の動作に影響なし

### 長期的効果
- [ ] 保守性の大幅向上
- [ ] テスト容易性の向上
- [ ] 再利用性の向上
- [ ] 拡張性の向上
- [ ] アーキテクチャの安定性

## 実装スケジュール

| Phase | 期間 | 主要タスク | 成果物 |
|-------|------|------------|--------|
| Phase 1 | 2-3日 | 準備作業・設計 | 設計書、依存関係マップ、新規サービス設計 |
| Phase 2.1 | 3-4日 | GUI層移行 | 拡張SearchFilterService、簡素化されたGUI層 |
| Phase 2.2 | 2-3日 | ワーカー層移行 | DatabaseOperationService、簡素化されたワーカー層 |
| Phase 2.3 | 2-3日 | ウィジェット層移行 | 拡張サービス、簡素化されたウィジェット層 |
| Phase 2.4 | 2-3日 | サービス層移行 | 統合されたサービス層 |
| Phase 3 | 1-2日 | インターフェース設計 | 統合されたシステム |
| Phase 4 | 1-2日 | 最終調整 | テスト完了、ドキュメント更新 |

**総期間**: 13-20日

## 次のステップ

1. **承認プロセス**: この更新された計画書のレビューと承認
2. **実装開始**: Phase 1の準備作業から開始
3. **進捗管理**: 各フェーズでの進捗確認と調整
4. **品質保証**: 継続的なテストとレビュー

---

**作成日**: 2025年1月27日
**更新日**: 2025年1月27日
**作成者**: AI Assistant
**バージョン**: 2.0
**ステータス**: 調査完了・計画更新済み
