# 画像処理機能 仕様書

## 1. 概要

本ドキュメントは、LoRAIro における画像処理機能の詳細な仕様を定義する。
主な処理フローは以下の通り。

```mermaid
graph TD
    A[入力画像] --> B(枠除去 / AutoCrop);
    B --> C(色空間正規化);
    C --> D{アップスケール判定};
    D -- 解像度不足 & Upscaler指定あり --> E[アップスケール];
    D -- 上記以外 --> F[リサイズ];
    E --> F;
    F --> G(WebP形式で保存); // FileSystemManager等で処理?
    G --> H[出力];
```

## 2. 機能詳細

### 2.1. アップスケール (Upscaler)

-   **目的:** 低解像度の画像を、指定されたAIモデルを用いて高解像度化する。
-   **実行条件:** 画像の長辺が `target_resolution` 未満であり、かつアップスケーラーが指定されている場合に実行される。ただし、RGBAモードの画像はスキップされる。
-   **使用ライブラリ:** `spandrel`, `torch`
-   **対応モデル:**
    -   `spandrel` ライブラリがサポートするモデルを原則として利用可能とする。
    -   初期実装では `RealESRGAN_x4plus` (デフォルトスケール: 4.0) を含む。
    -   利用可能なモデルリストの取得方法、モデルファイルのパス管理方法は別途定義する。(確認事項1)
-   **設定項目 (GUI経由で設定ファイルに保存):**
    -   使用するアップスケーラーモデル名 (利用可能なモデルから選択)
    -   (オプション) スケール倍率 (指定なければモデル推奨値を使用)
-   **注意点:** アップスケール後の画像サイズが `target_resolution` 未満の場合は処理をスキップする。アップスケール実行有無のメタデータ保存は検討事項。(確認事項1)

### 2.2. 枠除去 (AutoCrop)

-   **目的:** 画像の周囲にある単色またはグラデーションの枠（レターボックス、ピラーボックス等）を自動検出し、除去する。
-   **使用ライブラリ:** `cv2` (OpenCV), `scipy.ndimage`, `numpy`
-   **検出ロジック:**
    -   エッジ強度、色平均/標準偏差に基づく評価 (`_evaluate_edge`)
    -   差分画像と輪郭検出に基づく領域検出 (`_get_crop_area`)
    -   グラデーション検出 (`_detect_gradient`) - グラデーション検出時は枠なしと判断
-   **クロップ時のマージン:**
    -   **実装方式:** 動的計算(検出されたバウンディングボックスサイズに応じて自動調整)
    -   **計算式:**
        ```python
        margin_x = max(2, int(bbox_width * 0.005))
        margin_y = max(2, int(bbox_height * 0.005))
        ```
    -   **設計理由:**
        - バウンディングボックス基準: 実際に検出されたコンテンツ領域に対して適切なマージンを適用
        - 軸ごとの独立計算: 各軸で個別にマージン適用判定 (`bbox_width > 2 * margin_x`, `bbox_height > 2 * margin_y`)
        - 安全性チェック: 軸ごとに独立してマージンをスキップ(負の寸法を防止)
        - 最小マージン: 2px下限で極小バウンディングボックスを保護
    -   **例:**
        - バウンディングボックス 500x500 → margin_x=2px, margin_y=2px(両軸で最小値)
        - バウンディングボックス 1000x1000 → margin_x=5px, margin_y=5px(両軸で適用)
        - バウンディングボックス 2000x500 → margin_x=10px, margin_y=2px(軸ごとに異なる)
        - バウンディングボックス 1000x3 → margin_x=5px, margin_y=スキップ(3 <= 4で不十分)
        - バウンディングボックス 3x1000 → margin_x=スキップ(3 <= 4で不十分), margin_y=5px
        - バウンディングボックス 3x3 → margin_x=スキップ, margin_y=スキップ(両軸で不十分)
-   **設定項目 (GUI経由で設定ファイルに保存):**
    -   枠検出の閾値 (color_threshold, std_threshold, edge_threshold, gradient_threshold) - 設定可能にするか検討。(確認事項2)
    -   クロップ時のマージン - 設定可能にするか検討。(確認事項2)
-   **処理フロー:** `_get_crop_area` で検出した領域を `PIL.Image.crop` で切り出す。検出できない場合は元画像を返す。

### 2.3. リサイズ (ImageProcessor.resize_image)

-   **目的:** 画像を指定されたルールに基づき、学習に適した解像度にリサイズする。アスペクト比は維持される。
-   **使用ライブラリ:** `PIL` (Pillow)
-   **補間アルゴリズム:** `Image.Resampling.LANCZOS` (固定)
-   **リサイズルール:**
    1.  入力画像の幅・高さからアスペクト比を計算。
    2.  `preferred_resolutions` (優先解像度/アスペクト比リスト) 内に同じアスペクト比の指定が存在するか検索 (`_find_matching_resolution`)。
    3.  存在する場合: `target_resolution` の面積に最も近い優先解像度を採用。
    4.  存在しない場合:
        a.  画像の長辺が `target_resolution` になるように、アスペクト比を維持して短辺を計算。
        b.  計算された幅・高さをそれぞれ最も近い32の倍数に丸める。
-   **設定項目 (GUI経由で設定ファイルに保存):**
    -   `target_resolution` (目標解像度、長辺の基準)
    -   `preferred_resolutions` (優先解像度/アスペクト比リスト - 例: `[(512, 512), (768, 512), "3:2", "16:9"]`) - 文字列形式のサポートを追加検討。

### 2.4. 色空間正規化 (ImageProcessor.normalize_color_profile)

-   **目的:** 画像の色空間を入力処理に適した形式 (RGBまたはRGBA) に統一する。
-   **対応モード:** RGB, RGBA, CMYK, P (パレット)
-   **処理:**
    -   RGB/RGBA: アルファ有無に応じて RGB または RGBA に変換。
    -   CMYK: RGB に変換。
    -   P: RGB に変換後、再帰的に処理。
    -   その他: 未サポートとして警告後、RGB/RGBA に変換。

### 2.5. WebP形式への変換

-   **目的:** 処理済み画像を WebP 形式で保存する。
-   **実装箇所:** (要確認 - `FileSystemManager` 等での保存処理の一部か？) (確認事項3)
-   **使用ライブラリ:** `PIL` (Pillow) の `save` メソッド (推測)
-   **設定項目:**
    -   品質、ロスレス設定、圧縮メソッドはユーザー設定不要。内部で最適なデフォルト値を使用する。

---

**確認事項 (未解決):**

1.  **アップスケール:**
    *   利用可能なモデルリストの取得方法、モデルファイルのパス管理方法をどう定義しますか？ (例: 設定ファイルにリスト記述、特定のディレクトリをスキャン)
    *   アップスケールしたことを示すメタデータを保存しますか？
2.  **枠除去:**
    *   枠検出の閾値やクロップマージンは設定可能にしますか？ (デフォルト値で十分か、調整が必要か)
3.  **WebP変換:**
    *   この機能は `image_processor.py` 以外で実装されていますか？ (もしそうなら、該当箇所のコードも確認したいです)